# Сценарий 4 — WebSocket (Django Channels): realtime push и двусторонняя связь

## Идея
Поднять WebSocket‑канал: сервер пушит обновления цен и может получать от клиента события (например «какие cargo_id сейчас видим»). Идеально для realtime, но требует инфраструктуры.

## Архитектура
- Frontend:
  - `WebSocket` подключение
  - клиент отправляет список отображаемых cargo_id / текущие фильтры
  - сервер отправляет дифф цен
- Backend:
  - Django Channels + ASGI
  - слой pub/sub (обычно Redis) для fan‑out сообщений
  - фоновые воркеры/таски для опроса CargoTech и публикации обновлений

## Надёжность
Средняя:
- WebSocket может блокироваться/обрываться на мобильных и корпоративных прокси
- требуется retry/backoff, heartbeats, восстановление состояния

## Скорость
Максимальная:
- realtime push
- можно отправлять только изменения

## Нагрузка
- меньше HTTP‑запросов, но больше постоянных соединений
- дополнительная нагрузка на Redis/pubsub + ASGI воркеры

## Плюсы
- Лучшая latency и «живость» интерфейса
- Гибкость: можно точно синхронизировать только видимые карточки

## Минусы
- Самая высокая сложность внедрения и поддержки
- Требует Channels/Redis/ASGI, пересборки деплоя
- В Telegram WebApp может быть менее предсказуемо, чем обычный браузер

## Когда выбирать
- Проект уже использует Channels/ASGI и Redis
- Требуется строго realtime и двусторонние события

