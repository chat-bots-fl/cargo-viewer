# Сценарий 3 — Server‑Sent Events (SSE): сервер пушит обновления цен

## Идея
Клиент открывает `EventSource` соединение, а сервер периодически (или по событиям) отправляет сообщения с изменёнными ценами. Клиент обновляет DOM точечно.

## Архитектура
- Frontend:
  - `new EventSource("/api/cargos/prices/stream?...")`
  - обработчик `onmessage` обновляет цены в DOM
- Backend:
  - SSE endpoint держит HTTP‑соединение открытым
  - сервер периодически опрашивает CargoTech или читает обновления из внутреннего кеша/очереди

## Надёжность
Средняя:
- соединение долгоживущее, может рваться в моб. сетях/проксах
- Telegram WebView иногда агрессивно «усыпляет» фоновые соединения
- требуется корректная стратегия reconnection + last-event-id

## Скорость
Отличная:
- низкая latency, не нужно ждать следующего polling‑тика
- можно пушить только изменения (дифф)

## Нагрузка
- меньше запросов, чем при polling
- но больше нагрузки на сервер по удержанию активных соединений

## Плюсы
- «почти realtime»
- экономит HTTP‑запросы при большом онлайне (в сравнении с polling)

## Минусы
- Сложнее эксплуатация (таймауты, буферы, прокси)
- Нужно продумать совместимость с Telegram WebApp (reconnect, фон)
- В Django без ASGI/async это обычно менее удобно

## Когда выбирать
- Нужны near‑realtime обновления
- Есть опыт/инфраструктура для поддержания долгих соединений

